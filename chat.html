<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Hybrid Chat ‚Äî Settings Fixed</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
<style>
  :root{
    --bg:#f5f7fa; --sidebar:#2c3e50; --sidebar-active:#34495e; --accent:#3498db;
    --text:#222; --card:#fff; --self:#2ecc71; --other:#bdc3c7;
  }
  [data-theme="dark"]{
    --bg:#0f1112; --sidebar:#16202b; --sidebar-active:#25343e; --accent:#256aa2;
    --text:#eaeef0; --card:#151718; --self:#27ae60; --other:#4b5563;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,Arial,sans-serif}
  .stage{display:flex;justify-content:center;align-items:center;height:100vh;padding:12px;box-sizing:border-box}
  #app{display:flex;width:95%;max-width:1000px;height:84vh;border-radius:12px;overflow:hidden;box-shadow:0 8px 30px rgba(2,6,23,.12)}
  /* SIDEBAR */
  #sidebar{width:220px;background:var(--sidebar);color:#fff;padding:12px;box-sizing:border-box;display:flex;flex-direction:column}
  #sidebar h3{margin:0 0 12px;text-align:center;font-size:16px}
  .room-btn{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;border:0;background:transparent;color:#fff;margin:6px 0;cursor:pointer;font-weight:600}
  .room-btn:hover{background:rgba(255,255,255,0.04)}
  .room-btn.active{background:var(--sidebar-active)}
  .room-label{flex:1;text-align:left;padding-right:6px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .badge{background:#ff4d4f;border-radius:999px;padding:2px 7px;font-size:12px;margin-left:8px}
  .controls{margin-top:auto;display:flex;flex-direction:column;gap:8px}
  .btn-flat{background:var(--accent);border:0;color:#fff;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:700}
  .small-flat{background:transparent;border:1px solid rgba(255,255,255,0.08);color:#fff;padding:8px;border-radius:8px;cursor:pointer}
  /* MAIN */
  #main{flex:1;display:flex;flex-direction:column;background:var(--card)}
  header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:var(--accent);color:#fff}
  #headerLeft{display:flex;flex-direction:column}
  #title{font-weight:800}
  #subtitle{font-size:12px;opacity:.95}
  #headerRight{display:flex;gap:8px;align-items:center}
  #chat{flex:1;overflow:auto;padding:14px;box-sizing:border-box;background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent)}
  .msg{clear:both;max-width:72%;padding:10px 12px;border-radius:12px;margin:8px 0;word-break:break-word}
  .self{background:var(--self);color:#fff;float:right;border-bottom-right-radius:4px}
  .other{background:var(--other);float:left;color:#111;border-bottom-left-radius:4px}
  .meta{font-size:11px;color:rgba(0,0,0,0.45);margin-top:6px}
  footer{display:flex;gap:8px;padding:10px;background:transparent;border-top:1px solid rgba(0,0,0,0.06)}
  input.message{flex:1;padding:10px;border-radius:10px;border:1px solid #d6dbe0;font-size:14px}
  button.send{padding:10px 12px;border-radius:10px;border:0;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
  .delete-btn{background:none;border:0;color:rgba(255,255,255,.8);cursor:pointer;padding:6px;border-radius:6px}
  @media(max-width:800px){#sidebar{width:110px;padding:8px}.room-label{display:none}#app{height:92vh}}
  /* Settings modal */
  #settingsModal{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center}
  #settingsBox{background:var(--card);color:var(--text);padding:20px;border-radius:12px;width:320px;box-shadow:0 8px 30px rgba(2,6,23,.25)}
  #settingsBox h2{margin:0 0 8px 0}
  #settingsBox label{display:block;margin-top:8px;font-size:13px}
  #settingsBox input{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #ccc}
  #settingsBox .sbtn{width:100%;padding:10px;margin-top:10px;border-radius:8px;border:0;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
  #settingsBox .secondary{background:transparent;border:1px solid #bbb;color:var(--text)}
</style>
</head>
<body data-theme="light">
<div class="stage">
  <div id="app">
    <aside id="sidebar">
      <h3>Chats</h3>
      <div id="roomsContainer">
        <button class="room-btn active" data-room="Global"><span class="room-label">üåç Global</span></button>
      </div>
      <div class="controls">
        <button id="addFriend" class="btn-flat">+ New Chat</button>
        <button id="settingsBtn" class="small-flat">‚öôÔ∏è Settings</button>
      </div>
    </aside>

    <main id="main">
      <header>
        <div id="headerLeft"><div id="title">‚Äî</div><div id="subtitle">‚Äî</div></div>
        <div id="headerRight">
          <div id="typing" style="font-size:13px;opacity:.92"></div>
          <button id="themeToggle" class="delete-btn">üåô</button>
        </div>
      </header>

      <section id="chat"></section>

      <footer>
        <input id="msgInput" class="message" placeholder="Type a message‚Ä¶" disabled>
        <button id="sendBtn" class="send" disabled>Send</button>
      </footer>
    </main>
  </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal">
  <div id="settingsBox">
    <h2>Settings</h2>

    <label for="newUsername">Change Username</label>
    <input id="newUsername" type="text" placeholder="New username">

    <label for="newPassword">Change Password</label>
    <input id="newPassword" type="password" placeholder="New password">

    <button id="saveSettings" class="sbtn">Save changes</button>
    <button id="clearChats" class="sbtn secondary">Clear all chats</button>
    <button id="logoutBtn" class="sbtn secondary">Logout</button>
    <button id="closeSettings" class="sbtn secondary">Close</button>
  </div>
</div>

<script>
/* --------------------------
   Helper: same hash used by signup/login
   -------------------------- */
function hash(str){
  // simple deterministic JS hash (same as earlier signup/login)
  let h = 0;
  for (let i = 0; i < str.length; i++) {
    h = ((h << 5) - h) + str.charCodeAt(i);
    h |= 0;
  }
  return h.toString();
}

/* ======= Initialization & storage keys ======= */
const username = sessionStorage.getItem('username');
if(!username){ window.location.href='login.html'; throw ''; }

const ROOMS_KEY = username + '_rooms';
const UNREAD_KEY = username + '_unread';
const GLOBAL_KEY = 'globalMessages';
const SEEN_KEY = username + '_seen';

let rooms = JSON.parse(localStorage.getItem(ROOMS_KEY) || '{"Global":[]}');
let unread = JSON.parse(localStorage.getItem(UNREAD_KEY) || '{}');
let seen = new Set(JSON.parse(localStorage.getItem(SEEN_KEY) || '[]'));

/* UI refs */
const roomsContainer = document.getElementById('roomsContainer');
const chatEl = document.getElementById('chat');
const titleEl = document.getElementById('title');
const subtitleEl = document.getElementById('subtitle');
const typingEl = document.getElementById('typing');
const msgInput = document.getElementById('msgInput');
const sendBtn = document.getElementById('sendBtn');
const addFriendBtn = document.getElementById('addFriend');
const settingsBtn = document.getElementById('settingsBtn');
const settingsModal = document.getElementById('settingsModal');
const newUsernameInput = document.getElementById('newUsername');
const newPasswordInput = document.getElementById('newPassword');
const saveSettingsBtn = document.getElementById('saveSettings');
const clearChatsBtn = document.getElementById('clearChats');
const logoutBtn = document.getElementById('logoutBtn');
const closeSettingsBtn = document.getElementById('closeSettings');
const themeToggle = document.getElementById('themeToggle');

let currentRoom = 'Global';
let peer = null;
let connections = {}; // peerId => DataConnection

/* ========= Utilities ========= */
function saveState(){
  localStorage.setItem(ROOMS_KEY, JSON.stringify(rooms));
  localStorage.setItem(UNREAD_KEY, JSON.stringify(unread));
  localStorage.setItem(SEEN_KEY, JSON.stringify(Array.from(seen)));
}
function roomKey(a,b){ return [a,b].sort().join('_'); }
function otherNameFromRoomKey(rk){ if(rk==='Global') return 'Global'; const parts=rk.split('_'); return parts[0]===username?parts[1]:parts[0]; }
function makeId(){ return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,9); }

/* ======= Rendering ======= */
function renderRooms(){
  roomsContainer.innerHTML = '';
  // Global button
  const globalBtn = document.createElement('button');
  globalBtn.className = 'room-btn' + (currentRoom === 'Global' ? ' active' : '');
  globalBtn.dataset.room = 'Global';
  globalBtn.innerHTML = `<span class="room-label">üåç Global</span>` + (unread['Global'] ? `<span class="badge">${unread['Global']}</span>` : '');
  globalBtn.onclick = ()=>switchRoom('Global');
  roomsContainer.appendChild(globalBtn);

  const list = Object.keys(rooms).filter(r=>r!=='Global').sort((a,b)=>{
    const la = (rooms[a].length && rooms[a][rooms[a].length-1].time) || 0;
    const lb = (rooms[b].length && rooms[b][rooms[b].length-1].time) || 0;
    return lb - la;
  });
  for(const rk of list){
    const label = otherNameFromRoomKey(rk);
    const btn = document.createElement('button');
    btn.className = 'room-btn' + (currentRoom === rk ? ' active' : '');
    btn.dataset.room = rk;
    const badgeHTML = (unread[rk] ? `<span class="badge">${unread[rk]}</span>` : '');
    btn.innerHTML = `<span class="room-label">üí¨ ${label}</span>${badgeHTML}`;
    btn.onclick = ()=>switchRoom(rk);
    // delete icon
    const del = document.createElement('button');
    del.className = 'delete-btn';
    del.innerHTML = 'üóë';
    del.onclick = (e)=>{ e.stopPropagation(); deleteChat(rk); };
    btn.appendChild(del);
    roomsContainer.appendChild(btn);
  }
}

function renderChat(){
  titleEl.innerText = username + ' ‚Ä¢ ' + (currentRoom === 'Global' ? 'Global' : otherNameFromRoomKey(currentRoom));
  subtitleEl.innerText = currentRoom === 'Global' ? 'Public chat ‚Äî last 20 stored locally' : 'Private chat';
  chatEl.innerHTML = '';
  if(!rooms[currentRoom]) rooms[currentRoom] = [];
  for(const m of rooms[currentRoom]) appendMsgDOM(m);
  chatEl.scrollTop = chatEl.scrollHeight;
  unread[currentRoom] = 0;
  saveState();
  renderRooms();
}

function appendMsgDOM(obj){
  const d = document.createElement('div');
  d.className = 'msg ' + (obj.who === username ? 'self' : 'other');
  const text = document.createElement('div'); text.innerText = obj.msg;
  const meta = document.createElement('div'); meta.className='meta'; meta.innerText = `${obj.who} ‚Ä¢ ${new Date(obj.time).toLocaleTimeString()}`;
  d.appendChild(text); d.appendChild(meta); chatEl.appendChild(d);
}

/* ======= Flood/dedupe message handling ======= */
function handleIncomingMessage(data, fromPeer){
  if(!data || !data.id) return;
  if(seen.has(data.id)) return;
  seen.add(data.id);

  if(!rooms[data.room]) rooms[data.room] = [];
  rooms[data.room].push({who: data.from, msg: data.text, id: data.id, time: data.time});
  if(data.room === 'Global'){
    rooms['Global'] = rooms['Global'].slice(-40);
    localStorage.setItem(GLOBAL_KEY, JSON.stringify(rooms['Global'].slice(-20)));
  }
  if(currentRoom === data.room){
    appendMsgDOM({who:data.from,msg:data.text,time:data.time});
    chatEl.scrollTop = chatEl.scrollHeight;
  } else {
    unread[data.room] = (unread[data.room]||0) + 1;
    renderRooms();
  }
  saveState();

  // flood to peers except source
  for(const pid in connections){
    if(pid === fromPeer) continue;
    const c = connections[pid];
    if(c && c.open) { try{ c.send(data); }catch(e){} }
  }
}

function sendMessage(text){
  const id = makeId();
  const time = Date.now();
  const packet = { type:'msg', id, from: username, text, room: currentRoom, time };

  seen.add(id);
  if(!rooms[currentRoom]) rooms[currentRoom] = [];
  rooms[currentRoom].push({who: username, msg: text, id, time});
  if(currentRoom === 'Global'){ rooms['Global'] = rooms['Global'].slice(-40); localStorage.setItem(GLOBAL_KEY, JSON.stringify(rooms['Global'].slice(-20))); }
  renderChat();

  if(currentRoom === 'Global'){
    for(const pid in connections){
      const c = connections[pid];
      if(c && c.open) try{ c.send(packet); }catch(e){}
    }
  } else {
    const parts = currentRoom.split('_');
    const friend = parts[0] === username ? parts[1] : parts[0];
    const c = connections[friend];
    if(c && c.open) try{ c.send(packet); }catch(e){}
  }
  saveState();
}

/* ======= Connections ======= */
function setupConnection(conn){
  const peerId = conn.peer;
  connections[peerId] = conn;

  // ensure room exists for this pair
  const rk = roomKey(username, peerId);
  if(!rooms[rk]) rooms[rk] = [];
  if(!document.querySelector(`.room-btn[data-room="${rk}"]`)) addRoomButton(rk);

  conn.on('data', (data) => {
    if(!data || !data.type) return;
    if(data.type === 'msg') handleIncomingMessage(data, peerId);
    else if(data.type === 'typing') { if(data.room === currentRoom) showTyping(data.from); }
  });

  conn.on('open', () => {
    // send last global to requester (help late joiners)
    const toSend = (rooms['Global']||[]).slice(-20);
    for(const m of toSend){
      try{ conn.send({type:'msg', id: m.id || makeId(), from: m.who, text: m.msg, room:'Global', time: m.time || Date.now()}); }catch(e){}
    }
    renderRooms();
  });

  conn.on('close', ()=>{ delete connections[peerId]; });
  conn.on('error', ()=>{ delete connections[peerId]; });
}

/* ======= UI actions ======= */
function addRoomButton(roomKey){
  if(document.querySelector(`.room-btn[data-room="${roomKey}"]`)) return;
  const label = otherNameFromRoomKey(roomKey);
  const btn = document.createElement('button');
  btn.className = 'room-btn';
  btn.dataset.room = roomKey;
  const badgeHTML = (unread[roomKey] ? `<span class="badge">${unread[roomKey]}</span>` : '');
  btn.innerHTML = `<span class="room-label">üí¨ ${label}</span>${badgeHTML}`;
  btn.onclick = () => switchRoom(roomKey);
  if(roomKey !== 'Global'){
    const del = document.createElement('button'); del.className = 'delete-btn'; del.innerText = 'üóë';
    del.onclick = (e) => { e.stopPropagation(); deleteChat(roomKey); };
    btn.appendChild(del);
  }
  roomsContainer.appendChild(btn);
  renderRooms();
}

function switchRoom(roomKey){
  currentRoom = roomKey;
  renderChat();
}

function deleteChat(roomKey){
  if(roomKey === 'Global') return;
  if(!confirm('Delete conversation with '+ otherNameFromRoomKey(roomKey) +'?')) return;
  delete rooms[roomKey];
  delete unread[roomKey];
  saveState();
  const b = document.querySelector(`.room-btn[data-room="${roomKey}"]`);
  if(b) b.remove();
  if(currentRoom === roomKey) currentRoom = 'Global';
  renderChat();
}

function showTyping(who){
  typingEl.innerText = who + ' is typing...';
  clearTimeout(window._tTO);
  window._tTO = setTimeout(()=> typingEl.innerText = '', 1400);
}

/* ======= Add friend UI ======= */
addFriendBtn.onclick = () => {
  const friend = prompt('Enter username to chat with (exact):');
  if(!friend || friend === username) return;
  const rk = roomKey(username, friend);
  if(!rooms[rk]) rooms[rk] = [];
  unread[rk] = 0;
  saveState();
  if(!document.querySelector(`.room-btn[data-room="${rk}"]`)) addRoomButton(rk);
  if(!connections[friend]){
    try{
      const conn = peer.connect(friend, { reliable: true });
      conn.on('open', ()=> setupConnection(conn));
      conn.on('error', ()=> console.warn('conn error'));
    }catch(e){ console.warn(e); }
  }
};

/* ======= Typing -> send indicator ======= */
msgInput.addEventListener('input', () => {
  if(currentRoom === 'Global') return;
  const parts = currentRoom.split('_');
  const friend = parts[0] === username ? parts[1] : parts[0];
  const conn = connections[friend];
  if(conn && conn.open){
    try{ conn.send({type:'typing', from: username, room: currentRoom}); }catch(e){}
  }
});

/* ======= Send button ======= */
sendBtn.onclick = () => {
  const txt = msgInput.value.trim();
  if(!txt) return;
  sendMessage(txt);
  msgInput.value = '';
};

/* ======= Theme toggle ======= */
themeToggle.onclick = () => {
  const cur = document.body.getAttribute('data-theme') || 'light';
  document.body.setAttribute('data-theme', cur === 'light' ? 'dark' : 'light');
};

/* ======= Settings modal logic (FIXED password handling & username migration) ======= */
settingsBtn.onclick = ()=> { settingsModal.style.display = 'flex'; newUsernameInput.value=''; newPasswordInput.value=''; };
closeSettingsBtn.onclick = ()=> settingsModal.style.display = 'none';

saveSettingsBtn.onclick = ()=>{
  const newU = newUsernameInput.value.trim();
  const newP = newPasswordInput.value; // plaintext entry

  let users = JSON.parse(localStorage.getItem('users') || '{}');

  // Ensure current user exists in users (create if not)
  if(!users[username]){ users[username] = { password: hash('') }; } // if legacy missing, set empty hash

  // Change username flow
  if(newU && newU !== username){
    if(users[newU]) { alert('Username already taken. Choose another.'); return; }

    // compute new password hash: prefer newP if given, otherwise carry old hashed password
    const oldHashed = users[username] ? users[username].password : null;
    const newHashed = newP ? hash(newP) : oldHashed;

    // set new user record and remove old
    users[newU] = { password: newHashed };
    delete users[username];
    localStorage.setItem('users', JSON.stringify(users));

    // migrate rooms/unread/seen keys to new username keys
    const oldRoomsKey = username + '_rooms';
    const newRoomsKey = newU + '_rooms';
    const oldUnreadKey = username + '_unread';
    const newUnreadKey = newU + '_unread';
    const oldSeenKey = username + '_seen';
    const newSeenKey = newU + '_seen';

    // Save current in-memory rooms under new key
    localStorage.setItem(newRoomsKey, JSON.stringify(rooms || {"Global":[]}));
    localStorage.removeItem(oldRoomsKey);

    // unread
    localStorage.setItem(newUnreadKey, JSON.stringify(unread || {}));
    localStorage.removeItem(oldUnreadKey);

    // seen
    localStorage.setItem(newSeenKey, JSON.stringify(Array.from(seen)));
    localStorage.removeItem(oldSeenKey);

    alert('Username changed. You will be redirected to login with the new username.');
    sessionStorage.setItem('username', newU);
    // force logout so PeerJS will re-init with new id on next load
    sessionStorage.clear();
    window.location.href = 'login.html';
    return;
  }

  // Change password only
  if(newP){
    users[username] = users[username] || {};
    users[username].password = hash(newP);
    localStorage.setItem('users', JSON.stringify(users));
    alert('Password updated successfully.');
    newPasswordInput.value = '';
    return;
  }

  alert('No changes made.');
};

clearChatsBtn.onclick = ()=>{
  if(!confirm('Clear all your chats? This removes local chat history only.')) return;
  rooms = {"Global": []};
  unread = {};
  saveState();
  renderChat();
};

logoutBtn.onclick = ()=>{
  sessionStorage.clear();
  window.location.href = 'login.html';
};

/* ======= Boot: load persisted and start PeerJS ======= */
function loadInitial(){
  if(!rooms['Global'] || rooms['Global'].length === 0){
    rooms['Global'] = JSON.parse(localStorage.getItem(GLOBAL_KEY) || '[]');
  }
  for(const rk of Object.keys(rooms)) if(!unread[rk]) unread[rk] = 0;
  renderRooms();
  renderChat();
}
loadInitial();

peer = new Peer(username);
peer.on('open', id => {
  // auto connect known private rooms
  Object.keys(rooms).forEach(rk => {
    if(rk === 'Global') return;
    const friend = otherNameFromRoomKey(rk);
    if(friend && friend !== username && !connections[friend]){
      try{
        const conn = peer.connect(friend, { reliable: true });
        conn.on('open', ()=> setupConnection(conn));
      }catch(e){}
    }
  });
  renderRooms();
});
peer.on('connection', conn => { conn.on('open', ()=> setupConnection(conn)); });

peer.on('open', ()=> { msgInput.disabled = false; sendBtn.disabled = false; });

window.addEventListener('beforeunload', ()=> saveState());

</script>
</body>
</html>
