<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Hybrid Chat ‚Äî Stable</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
<style>
:root{
  --bg:#f5f7fa; --sidebar:#2c3e50; --sidebar-active:#34495e; --accent:#3498db;
  --text:#222; --card:#fff; --self:#2ecc71; --other:#bdc3c7;
}
[data-theme="dark"]{
  --bg:#0f1112; --sidebar:#16202b; --sidebar-active:#25343e; --accent:#256aa2;
  --text:#eaeef0; --card:#151718; --self:#27ae60; --other:#4b5563;
}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter, Arial, sans-serif}
.stage{display:flex;justify-content:center;align-items:center;height:100vh;padding:12px;box-sizing:border-box}
#app{display:flex;width:95%;max-width:1000px;height:84vh;border-radius:12px;overflow:hidden;box-shadow:0 8px 30px rgba(2,6,23,.12)}
/* sidebar */
#sidebar{width:220px;background:var(--sidebar);color:#fff;padding:12px;box-sizing:border-box;display:flex;flex-direction:column}
#sidebar h3{margin:0 0 12px;text-align:center;font-size:16px}
.room-btn{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;border:0;background:transparent;color:#fff;margin:6px 0;cursor:pointer;font-weight:600}
.room-btn:hover{background:rgba(255,255,255,0.04)}
.room-btn.active{background:var(--sidebar-active)}
.room-label{flex:1;text-align:left;padding-right:6px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.badge{background:#ff4d4f;border-radius:999px;padding:2px 7px;font-size:12px;margin-left:8px}
.controls{margin-top:auto;display:flex;gap:8px}
.btn-flat{background:var(--accent);border:0;color:#fff;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:700}
.small-flat{background:transparent;border:1px solid rgba(255,255,255,0.08);color:#fff;padding:6px 8px;border-radius:8px;cursor:pointer}
/* main */
#main{flex:1;display:flex;flex-direction:column;background:var(--card)}
header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:var(--accent);color:#fff}
#headerLeft{display:flex;flex-direction:column}
#title{font-weight:800}
#subtitle{font-size:12px;opacity:.95}
#headerRight{display:flex;gap:8px;align-items:center}
#chat{flex:1;overflow:auto;padding:14px;box-sizing:border-box;background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent)}
.msg{clear:both;max-width:72%;padding:10px 12px;border-radius:12px;margin:8px 0;word-break:break-word}
.self{background:var(--self);color:#fff;float:right;border-bottom-right-radius:4px}
.other{background:var(--other);float:left;color:#111;border-bottom-left-radius:4px}
.meta{font-size:11px;color:rgba(0,0,0,0.45);margin-top:6px}
footer{display:flex;gap:8px;padding:10px;background:transparent;border-top:1px solid rgba(0,0,0,0.06)}
input.message{flex:1;padding:10px;border-radius:10px;border:1px solid #d6dbe0;font-size:14px}
button.send{padding:10px 12px;border-radius:10px;border:0;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
.delete-btn{background:none;border:0;color:rgba(255,255,255,.8);cursor:pointer;padding:6px;border-radius:6px}
@media(max-width:800px){
  #sidebar{width:110px;padding:8px} .room-label{display:none}
  #app{height:92vh}
}

/* Settings modal */
#settingsModal{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center}
#settingsBox{background:var(--card);color:var(--text);padding:18px;border-radius:10px;width:320px;box-shadow:0 8px 24px rgba(0,0,0,0.25)}
#settingsBox h3{margin:0 0 8px}
.setting-row{display:flex;align-items:center;justify-content:space-between;margin:10px 0}
.sbtn{width:100%;padding:10px;border-radius:8px;border:0;background:var(--accent);color:#fff;font-weight:700;cursor:pointer;margin-top:8px}
.secondary{background:transparent;border:1px solid #bbb;color:var(--text)}
</style>
</head>
<body>
<div class="stage">
  <div id="app">
    <aside id="sidebar">
      <h3>Chats</h3>
      <div id="roomsContainer"></div>
      <div class="controls">
        <button id="addFriend" class="btn-flat">+ New Chat</button>
        <button id="openSettings" class="small-flat">‚öô Settings</button>
      </div>
    </aside>

    <main id="main">
      <header>
        <div id="headerLeft">
          <div id="title">‚Äî</div>
          <div id="subtitle">‚Äî</div>
        </div>
        <div id="headerRight">
          <div id="typing" style="font-size:13px;opacity:.92"></div>
        </div>
      </header>

      <section id="chat"></section>

      <footer>
        <input id="msgInput" class="message" placeholder="Type a message‚Ä¶" disabled>
        <button id="sendBtn" class="send" disabled>Send</button>
      </footer>
    </main>
  </div>
</div>

<!-- Settings -->
<div id="settingsModal">
  <div id="settingsBox">
    <h3>Settings</h3>

    <div class="setting-row">
      <div>Theme</div>
      <select id="themeSelect">
        <option value="light">Light</option>
        <option value="dark">Dark</option>
      </select>
    </div>

    <div class="setting-row">
      <div>Notifications</div>
      <select id="notifySelect">
        <option value="ask">Ask</option>
        <option value="on">On</option>
        <option value="off">Off</option>
      </select>
    </div>

    <button id="logoutBtn" class="sbtn secondary">Logout</button>
    <button id="closeSettings" class="sbtn secondary">Close</button>
  </div>
</div>

<script>
/* ========= Configuration ========= */
const MAX_ROOM_MESSAGES = 100;   // keep in memory
const MAX_PERSISTED = 30;        // per room persisted (global uses this)
const PING_INTERVAL = 30000;     // ms

/* ========= Basic state & storage keys ========= */
const username = sessionStorage.getItem('username');
if(!username){ window.location.href='login.html'; throw ''; }

const ROOMS_KEY = username + '_rooms';
const UNREAD_KEY = username + '_unread';
const SEEN_KEY = username + '_seen';
const GLOBAL_KEY = 'globalMessages';
const THEME_KEY = 'hybrid_theme';
const NOTIFY_PREF_KEY = 'hybrid_notify_pref';

let rooms = JSON.parse(localStorage.getItem(ROOMS_KEY) || '{"Global":[]}');
let unread = JSON.parse(localStorage.getItem(UNREAD_KEY) || '{}');
let seen = new Set(JSON.parse(localStorage.getItem(SEEN_KEY) || '[]'));

const roomsContainer = document.getElementById('roomsContainer');
const chatEl = document.getElementById('chat');
const titleEl = document.getElementById('title');
const subtitleEl = document.getElementById('subtitle');
const typingEl = document.getElementById('typing');
const msgInput = document.getElementById('msgInput');
const sendBtn = document.getElementById('sendBtn');
const addFriendBtn = document.getElementById('addFriend');
const openSettingsBtn = document.getElementById('openSettings');
const settingsModal = document.getElementById('settingsModal');
const themeSelect = document.getElementById('themeSelect');
const notifySelect = document.getElementById('notifySelect');
const logoutBtn = document.getElementById('logoutBtn');
const closeSettingsBtn = document.getElementById('closeSettings');

let currentRoom = 'Global';
let peer = null;
let connections = {}; // peerId -> conn

/* ========= Utilities ========= */
function saveState(){
  try{
    localStorage.setItem(ROOMS_KEY, JSON.stringify(rooms));
    localStorage.setItem(UNREAD_KEY, JSON.stringify(unread));
    localStorage.setItem(SEEN_KEY, JSON.stringify(Array.from(seen)));
  }catch(e){
    console.warn('saveState failed', e);
  }
}
function roomKey(a,b){ return [a,b].sort().join('_'); }
function otherNameFromRoomKey(rk){
  if(rk === 'Global') return 'Global';
  const parts = rk.split('_');
  return parts[0] === username ? parts[1] : parts[0];
}
function makeId(){ return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,9); }

/* ========= Rendering ========= */
function renderRooms(){
  roomsContainer.innerHTML = '';
  // Global
  const globalBtn = document.createElement('button');
  globalBtn.className = 'room-btn' + (currentRoom === 'Global' ? ' active' : '');
  globalBtn.dataset.room = 'Global';
  globalBtn.innerHTML = `<span class="room-label">üåç Global</span>` + (unread['Global'] ? `<span class="badge">${unread['Global']}</span>` : '');
  globalBtn.onclick = ()=> switchRoom('Global');
  roomsContainer.appendChild(globalBtn);

  // private rooms (sorted newest first)
  const others = Object.keys(rooms).filter(r=>r!=='Global').sort((a,b)=>{
    const ta = rooms[a].length?rooms[a][rooms[a].length-1].time:0;
    const tb = rooms[b].length?rooms[b][rooms[b].length-1].time:0;
    return tb - ta;
  });

  for(const rk of others){
    const btn = document.createElement('button');
    btn.className = 'room-btn' + (currentRoom===rk ? ' active' : '');
    btn.dataset.room = rk;
    btn.innerHTML = `<span class="room-label">üí¨ ${otherNameFromRoomKey(rk)}</span>` + (unread[rk] ? `<span class="badge">${unread[rk]}</span>` : '');
    btn.onclick = ()=> switchRoom(rk);

    const del = document.createElement('button');
    del.className = 'delete-btn';
    del.innerText = 'üóë';
    del.onclick = (e)=> { e.stopPropagation(); deleteChat(rk); };
    btn.appendChild(del);

    roomsContainer.appendChild(btn);
  }
}

function renderChat(){
  titleEl.innerText = username + ' ‚Ä¢ ' + (currentRoom === 'Global' ? 'Global' : otherNameFromRoomKey(currentRoom));
  subtitleEl.innerText = currentRoom === 'Global' ? 'Public chat ‚Äî last ' + MAX_PERSISTED + ' saved locally' : 'Private chat';
  chatEl.innerHTML = '';
  if(!rooms[currentRoom]) rooms[currentRoom] = [];
  for(const m of rooms[currentRoom]) appendMsgDOM(m);
  chatEl.scrollTop = chatEl.scrollHeight;
  unread[currentRoom] = 0;
  saveState();
  renderRooms();
}

function appendMsgDOM(obj){
  const d = document.createElement('div');
  d.className = 'msg ' + (obj.who === username ? 'self' : 'other');
  const text = document.createElement('div'); text.innerText = obj.msg;
  const meta = document.createElement('div'); meta.className='meta'; meta.innerText = `${obj.who} ‚Ä¢ ${new Date(obj.time).toLocaleTimeString()}`;
  d.appendChild(text); d.appendChild(meta); chatEl.appendChild(d);
}

/* ========= Notifications ========= */
function requestNotificationPermissionIfNeeded(){
  const pref = localStorage.getItem(NOTIFY_PREF_KEY) || 'ask';
  if(pref === 'ask'){
    if("Notification" in window && Notification.permission === 'default'){
      Notification.requestPermission().then(()=>{/* no-op */});
    }
  }
}
function notify(title, body){
  const pref = localStorage.getItem(NOTIFY_PREF_KEY) || 'ask';
  if(pref === 'off') return;
  if(pref === 'ask' && Notification.permission !== 'granted') return;
  if(!("Notification" in window)) return;
  try{
    new Notification(title, { body, icon: '' });
  }catch(e){}
}

/* ========= Messaging & Flood/Dedupe ========= */
function handleIncomingMessage(data, fromPeer){
  if(!data || !data.id) return;
  if(seen.has(data.id)) return;       // dedupe
  seen.add(data.id);
  saveState();

  if(!rooms[data.room]) rooms[data.room] = [];
  rooms[data.room].push({ who: data.from, msg: data.text, id: data.id, time: data.time });
  // trim in-memory
  rooms[data.room] = rooms[data.room].slice(-MAX_ROOM_MESSAGES);

  // persist last N for global
  if(data.room === 'Global'){
    localStorage.setItem(GLOBAL_KEY, JSON.stringify(rooms['Global'].slice(-MAX_PERSISTED)));
  }

  // UI
  if(currentRoom === data.room){
    appendMsgDOM({ who: data.from, msg: data.text, time: data.time });
    chatEl.scrollTop = chatEl.scrollHeight;
  } else {
    unread[data.room] = (unread[data.room] || 0) + 1;
    renderRooms();
  }

  // notify if not viewing or page hidden
  if(currentRoom !== data.room || document.hidden){
    const roomLabel = data.room === 'Global' ? 'Global' : otherNameFromRoomKey(data.room);
    notify(`${roomLabel} ‚Äî ${data.from}`, data.text);
  }

  // flood-forward to other peers (except where it came from)
  for(const pid in connections){
    if(pid === fromPeer) continue;
    const c = connections[pid];
    if(c && c.open){
      try{ c.send(data); }catch(e){}
    }
  }
}

function sendMessage(text){
  const id = makeId(), time = Date.now();
  const packet = { type: 'msg', id, from: username, text, room: currentRoom, time };

  // mark seen and persist
  seen.add(id); saveState();

  if(!rooms[currentRoom]) rooms[currentRoom] = [];
  rooms[currentRoom].push({ who: username, msg: text, id, time });
  rooms[currentRoom] = rooms[currentRoom].slice(-MAX_ROOM_MESSAGES);

  if(currentRoom === 'Global'){
    localStorage.setItem(GLOBAL_KEY, JSON.stringify(rooms['Global'].slice(-MAX_PERSISTED)));
  }

  // immediate UI
  renderChat();

  // send out
  if(currentRoom === 'Global'){
    for(const pid in connections){
      const c = connections[pid];
      if(c && c.open) try{ c.send(packet); }catch(e){}
    }
  } else {
    const parts = currentRoom.split('_');
    const friend = parts[0] === username ? parts[1] : parts[0];
    const c = connections[friend];
    if(c && c.open) try{ c.send(packet); }catch(e){
      // try to connect then send once open
      tryConnectAndSend(friend, packet);
    }
  }
}

/* ========= Connection handling (robust) ========= */
function tryConnectAndSend(peerId, packet){
  if(!peerId || peerId === username) return;
  if(connections[peerId] && connections[peerId].open){
    try{ connections[peerId].send(packet); return; }catch(e){}
  }
  // attempt connection and send on open
  try {
    const c = peer.connect(peerId, { reliable: true });
    c.on('open', ()=>{ setupConnection(c); try{ c.send(packet); }catch(e){} });
    c.on('error', ()=>{ /* ignore */ });
  }catch(e){}
}

function setupConnection(conn){
  const pid = conn.peer;
  connections[pid] = conn;

  // ensure private room exists
  const rk = roomKey(username, pid);
  if(!rooms[rk]) rooms[rk] = [];

  conn.on('data', data => {
    if(!data || !data.type) return;
    if(data.type === 'msg') handleIncomingMessage(data, pid);
    else if(data.type === 'typing' && data.room === currentRoom) showTyping(data.from);
    else if(data.type === 'ping'){ /* keep-alive */ }
  });

  conn.on('open', () => {
    // give them our recent global messages (helps late joiners)
    try {
      const toSend = (rooms['Global'] || []).slice(-MAX_PERSISTED);
      toSend.forEach(m=>{
        conn.send({ type:'msg', id: m.id || makeId(), from: m.who, text: m.msg, room: 'Global', time: m.time || Date.now() });
      });
    }catch(e){}
    renderRooms();
  });

  conn.on('close', ()=> { delete connections[pid]; });
  conn.on('error', ()=> { delete connections[pid]; });
}

/* ========= UI interactions ========= */
function addRoomButton(roomKey){
  if(document.querySelector(`.room-btn[data-room="${roomKey}"]`)) return;
  const label = otherNameFromRoomKey(roomKey);
  const btn = document.createElement('button');
  btn.className = 'room-btn' + (currentRoom === roomKey ? ' active' : '');
  btn.dataset.room = roomKey;
  btn.innerHTML = `<span class="room-label">üí¨ ${label}</span>` + (unread[roomKey] ? `<span class="badge">${unread[roomKey]}</span>` : '');
  btn.onclick = ()=> switchRoom(roomKey);
  const del = document.createElement('button');
  del.className = 'delete-btn';
  del.innerText = 'üóë';
  del.onclick = (e)=>{ e.stopPropagation(); deleteChat(roomKey); };
  btn.appendChild(del);
  roomsContainer.appendChild(btn);
  renderRooms();
}

function switchRoom(roomKey){
  currentRoom = roomKey;
  renderChat();
}

function deleteChat(roomKey){
  if(roomKey === 'Global') return;
  if(!confirm('Delete conversation with ' + otherNameFromRoomKey(roomKey) + '?')) return;
  delete rooms[roomKey];
  delete unread[roomKey];
  saveState();
  const b = document.querySelector(`.room-btn[data-room="${roomKey}"]`);
  if(b) b.remove();
  if(currentRoom === roomKey) currentRoom = 'Global';
  renderChat();
}

function showTyping(who){
  typingEl.innerText = who + ' is typing...';
  clearTimeout(window._typingTO);
  window._typingTO = setTimeout(()=> typingEl.innerText = '', 1200);
}

/* ========= Add friend / connect ========= */
addFriendBtn.onclick = () => {
  const friend = prompt('Enter username to chat with (exact):');
  if(!friend || friend === username) return;
  const rk = roomKey(username, friend);
  if(!rooms[rk]) rooms[rk] = [];
  unread[rk] = 0;
  saveState();
  if(!document.querySelector(`.room-btn[data-room="${rk}"]`)) addRoomButton(rk);
  // try to connect immediately (will also be accepted when they connect back)
  try {
    const c = peer.connect(friend, { reliable: true });
    c.on('open', ()=> setupConnection(c));
    c.on('error', ()=> console.warn('connect error'));
  }catch(e){ console.warn(e); }
};

/* ========= Typing indicator sending ========= */
msgInput.addEventListener('input', ()=>{
  if(currentRoom === 'Global') return;
  const parts = currentRoom.split('_');
  const friend = parts[0] === username ? parts[1] : parts[0];
  const c = connections[friend];
  if(c && c.open) try{ c.send({ type:'typing', from: username, room: currentRoom }); }catch(e){}
});

/* ========= Send UI ========= */
sendBtn.onclick = ()=>{ const v = msgInput.value.trim(); if(!v) return; sendMessage(v); msgInput.value=''; };
msgInput.addEventListener('keydown', e => { if(e.key === 'Enter') sendBtn.click(); });

/* ========= Settings modal ========= */
openSettingsBtn.onclick = ()=>{
  settingsModal.style.display = 'flex';
  const currentTheme = localStorage.getItem(THEME_KEY) || 'light';
  themeSelect.value = currentTheme;
  const pref = localStorage.getItem(NOTIFY_PREF_KEY) || 'ask';
  notifySelect.value = pref;
};
closeSettingsBtn.onclick = ()=> settingsModal.style.display = 'none';

themeSelect.onchange = ()=>{
  localStorage.setItem(THEME_KEY, themeSelect.value);
  document.body.setAttribute('data-theme', themeSelect.value === 'dark' ? 'dark' : 'light');
};
notifySelect.onchange = ()=>{
  localStorage.setItem(NOTIFY_PREF_KEY, notifySelect.value);
  if(notifySelect.value === 'on') {
    if("Notification" in window && Notification.permission !== 'granted'){
      Notification.requestPermission();
    }
  }
};
logoutBtn.onclick = ()=>{ sessionStorage.removeItem('username'); window.location.href='login.html'; };

/* ========= Keep-alive pings ========= */
setInterval(()=>{
  for(const pid in connections){
    const c = connections[pid];
    if(c && c.open){
      try{ c.send({ type:'ping', from: username }); }catch(e){}
    }
  }
}, PING_INTERVAL);

/* ========= Initial load & PeerJS bootstrap ========= */
function loadInitial(){
  // load persisted global
  if(!rooms['Global'] || rooms['Global'].length === 0){
    rooms['Global'] = JSON.parse(localStorage.getItem(GLOBAL_KEY) || '[]');
  }
  for(const rk of Object.keys(rooms)) if(!unread[rk]) unread[rk] = 0;
  // apply theme
  const savedTheme = localStorage.getItem(THEME_KEY) || 'light';
  document.body.setAttribute('data-theme', savedTheme === 'dark' ? 'dark' : 'light');
  // notification pref
  const np = localStorage.getItem(NOTIFY_PREF_KEY) || 'ask';
  if(np === 'on' && "Notification" in window && Notification.permission !== 'granted') Notification.requestPermission();
  renderRooms(); renderChat();
}
loadInitial();

// PeerJS init: use username as peer id
peer = new Peer(username);
peer.on('open', id => {
  // auto connect to saved private rooms
  Object.keys(rooms).forEach(rk=>{
    if(rk === 'Global') return;
    const friend = otherNameFromRoomKey(rk);
    if(friend && friend !== username && !connections[friend]){
      try{
        const c = peer.connect(friend, { reliable: true });
        c.on('open', ()=> setupConnection(c));
        c.on('error', ()=>{/*ignore*/});
      }catch(e){}
    }
  });
  renderRooms();
  // enable UI
  msgInput.disabled = false; sendBtn.disabled = false;
});

// accept incoming
peer.on('connection', conn => {
  // ensure setup once open
  conn.on('open', ()=> setupConnection(conn));
  conn.on('error', ()=> console.warn('incoming conn error'));
});

// save state on unload
window.addEventListener('beforeunload', ()=> saveState());

</script>
</body>
</html>
